<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Let's Tree - First three.js project</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="icon" type="image/png" href="assets/robot.png">
    <link type="text/css" rel="stylesheet" href="reset.css">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
			{
				"imports": {
					"three": "./lib/three.module.js"
				}
			}
		</script>
		<script type="module">
      import * as THREE from 'three';
      import Stats from './lib/stats.module.js';
      import { GUI } from './lib/lil-gui.module.min.js';
      import { GLTFLoader } from './lib/GLTFLoader.js';


      let container, stats, clock, gui, mixer, actions, activeAction, previousAction;
			let camera, scene, renderer, model, face;

			const api = { state: 'Idle' };

			init();
			animate();

			function init() {
        container = document.createElement( 'div' );
        document.body.appendChild( container );

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.TextureLoader().load( './assets/background.jpg' );
        scene.background.encoding = THREE.sRGBEncoding;

        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 100 );
				camera.position.set( - 5, 3, 10 );
				camera.lookAt( new THREE.Vector3( 0, 2, 0 ) );

        const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 20, 0 );
				scene.add( hemiLight );

        const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( 0, 20, 10 );
				scene.add( dirLight );

        const loader = new GLTFLoader();
				loader.load( 'models/RobotExpressive.glb', function ( gltf ) {
					model = gltf.scene;
          model.position.set(3, -3, -10);
					scene.add( model );
					createGUI( model, gltf.animations );
				}, undefined, function ( e ) {
					console.error( e );
				} );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );
      }
      
      function createGUI( model, animations ) {
        const states = [ 'Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing' ];
        const emotes = [ 'Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp' ];

        gui = new GUI();
        mixer = new THREE.AnimationMixer( model );
        actions = {};
        for ( let i = 0; i < animations.length; i ++ ) {
          const clip = animations[ i ];
          const action = mixer.clipAction( clip );
          actions[ clip.name ] = action;
          if ( emotes.indexOf( clip.name ) >= 0 || states.indexOf( clip.name ) >= 4 ) {
            action.clampWhenFinished = true;
            action.loop = THREE.LoopOnce;
          }
        }

        // states
				const statesFolder = gui.addFolder( 'States' );
        const clipCtrl = statesFolder.add( api, 'state' ).options( states );
        clipCtrl.onChange( function () {
          fadeToAction( api.state, 0.5 );
        } );
        statesFolder.open();

        // emotes

				const emoteFolder = gui.addFolder( 'Emotes' );
        function createEmoteCallback( name ) {
          api[ name ] = function () {
            fadeToAction( name, 0.2 );
            mixer.addEventListener( 'finished', restoreState );
          };
          emoteFolder.add( api, name );
        }

        function restoreState() {
          mixer.removeEventListener( 'finished', restoreState );
          fadeToAction( api.state, 0.2 );
        }

        for ( let i = 0; i < emotes.length; i ++ ) {
          createEmoteCallback( emotes[ i ] );
        }
        emoteFolder.open();

        // expressions

				face = model.getObjectByName( 'Head_4' );
        const expressions = Object.keys( face.morphTargetDictionary );
        const expressionFolder = gui.addFolder( 'Expressions' );
        for ( let i = 0; i < expressions.length; i ++ ) {
          expressionFolder.add( face.morphTargetInfluences, i, 0, 1, 0.01 ).name( expressions[ i ] );
        }

        function randomAction() {
          const newEmote = (Math.round(Math.random())) ? 'Wave' : 'ThumbsUp';
          fadeToAction(newEmote, 0.2);
          mixer.addEventListener( 'finished', restoreState );
        }

        setInterval(randomAction, 5000);

        activeAction = actions[ 'Idle' ];
        activeAction.play();
        expressionFolder.open();
      }

      function fadeToAction( name, duration ) {

        previousAction = activeAction;
        activeAction = actions[ name ];

        if ( previousAction !== activeAction ) {
          previousAction.fadeOut( duration );
        }

        activeAction
          .reset()
          .setEffectiveTimeScale( 1 )
          .setEffectiveWeight( 1 )
          .fadeIn( duration )
          .play();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function animate() {
        const dt = clock.getDelta();
        if ( mixer ) mixer.update( dt );
        requestAnimationFrame( animate );
        renderer.render( scene, camera );
        stats.update();
      }
		</script>
	</body>
</html>